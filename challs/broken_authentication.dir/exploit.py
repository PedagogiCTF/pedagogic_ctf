#!/usr/bin/python3
import base64
import hashlib
import subprocess
import sys


def run_cmd(correction_file, args):

    args.insert(0, correction_file)

    if correction_file.endswith('.py'):
        args.insert(0, 'python3')
    elif correction_file.endswith('.pl'):
        args.insert(0, 'perl')
    elif correction_file.endswith('.go'):
        args.insert(0, 'run')
        args.insert(0, 'go')

    child = subprocess.Popen(args, stdout=subprocess.PIPE)
    streamdata = child.communicate()[0]
    ret = child.returncode
    return streamdata.decode(), ret


def exploit(correction_file, secret):
    """
        Check if the corrected source code is still vulnerable
    """
    # Try to login with the old determinist token generation
    token = hashlib.sha1(base64.b64encode(b"random_user")).hexdigest()
    out, _ = run_cmd(correction_file, ['random_user', '', '/get-token'])
    if token in out:
        print("I'm still able to craft a valid token!")
        return True

    # Try to generate a bunch of tokens to see if the algorithm is deterministic
    # (in the real world a manual review of the algorithm is of course needed)
    outputs = set()
    for _ in range(20):
        old_len = len(outputs)
        out, _ = run_cmd(correction_file, ['test', '', '/get-token'])
        outputs.add(out)
        if len(outputs) == old_len:
            print('The algorithm used to generate the token looks too deterministic\n')
            return True

    return False


def main():

    secret = sys.argv[1]
    correction_file = sys.argv[2]
    return_code = 3 if exploit(correction_file, secret) else 0
    sys.exit(return_code)


if __name__ == "__main__":
    main()
