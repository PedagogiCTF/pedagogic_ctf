#!/usr/bin/python3

import re
import subprocess
import sys


def run_cmd(correction_file, args):

    args.insert(0, correction_file)

    if correction_file.endswith('.py'):
        args.insert(0, 'python3')
    elif correction_file.endswith('.pl'):
        args.insert(0, 'perl')
    elif correction_file.endswith('.go'):
        args.insert(0, 'run')
        args.insert(0, 'go')

    child = subprocess.Popen(args, stdout=subprocess.PIPE)
    streamdata = child.communicate()[0]
    ret = child.returncode
    return streamdata.decode(), ret


def exploit(correction_file, secret):
    """
        Check if the corrected source code is still vulnerable
    """
    out, _ = run_cmd(correction_file, ['test1', '', '/accounts/new'])
    reg = r'Your account (.*) has been successfully created'
    search = re.search(reg, out, re.I)
    if not search:
        print('Unable to extract account id')
        return False

    account_id = search.group(1)

    reg = r'Your associated token is (.*)'
    search = re.search(reg, out, re.I)
    if not search:
        print('Unable to extract token')
        return False

    token = search.group(1)
    out, _ = run_cmd(correction_file, ['test1', token, '/accounts/1/details'])
    if secret.lower() in out.lower():
        print("It's still possible to get sensitive account")
        return True

    out, _ = run_cmd(correction_file, ['test2', token, '/accounts/{}/details'.format(account_id)])
    if 'balance' in out.lower():
        print("User test2 can access account id {} owned by test1".format(account_id))
        return True

    return False


def main():

    correction_file = sys.argv[1]
    secret = sys.argv[2]
    return_code = 3 if exploit(correction_file, secret) else 0
    sys.exit(return_code)


if __name__ == "__main__":
    main()
